module Octizys.Effects.Parser.Combinators
  ( errorMessage
  , errorNamed
  , errorEof
  , errorRaw
  , errorCustom
  , Span (start, end)
  , item
  , satisfy
  , lookupNext
  , takeWhileP
  , takeWhile1P
  , try
  , alternative
  , optional
  , many
  , some
  , sepBy
  , sepBy1
  ) where

import Control.Arrow ((<<<))
import Data.Text (Text)
import Data.Text qualified as Text
import Effectful (Eff, (:>))
import Octizys.Effects.Parser.Effect
  ( Expectations (Expectations')

  , Parser (PutParseState, ThrowParseError)
  , ParserError
    ( GeneratedErrror
    , SimpleError
    , expected
    , sourcePosition
    , unexpected, CustomError
    )
  , ParserState (expected, position, remainStream)
  , Position (Position', column, line, offset)
  , Unexpected (UnexpectedEndOfInput, UnexpectedName, UnexpectedRaw)
  , getParseState
  , putParseState
  , throwParseError, catchParseError
  )

import Data.List.NonEmpty (NonEmpty ((:|)))
import Data.List.NonEmpty qualified as NonEmpty
import Effectful.Error.Dynamic (catchError)


{- | Represents the start and end positions
of an input.
-}
data Span = Span'
  { start :: Position
  , end :: Position
  }
  deriving (Show, Eq, Ord)


-- | == Auxiliar functions

-- | === Errors
emptyExpectations :: Expectations
emptyExpectations = Expectations' mempty


-- | Throw a error with the given message.
errorMessage
  :: Parser e :> es
  => Text
  -> Eff es a
errorMessage =
  throwParseError <<< SimpleError


-- | Throw a error with the given message.
errorCustom
  :: Parser e :> es
  => e
  -> Eff es a
errorCustom =
  throwParseError <<< CustomError


{- | Build a `GeneratedErrror` using the current position
and expectations.
-}
makeGeneratedError
  :: Parser e :> es
  => Unexpected
  -> Eff es (ParserError e)
makeGeneratedError unexpectedItem = do
  s <- getParseState
  pure
    GeneratedErrror
      { sourcePosition = s.position
      , unexpected = unexpectedItem
      , expected = s.expected
      }


-- | Throws a end of input error.
errorEof :: Parser e :> es => Eff es a
errorEof = do
  -- TODO: handle expected set
  err <- makeGeneratedError UnexpectedEndOfInput
  throwParseError err


-- | Throws a unexpected error on the original text of the source.
errorRaw
  :: Parser e :> es
  => NonEmpty Char
  -> Eff es a
errorRaw originalText = do
  -- TODO: handle expected set
  err <- makeGeneratedError (UnexpectedRaw originalText)
  throwParseError err


-- | Throws a unexpected error with a custom name.
errorNamed
  :: Parser e :> es
  => NonEmpty Char
  -> Eff es a
errorNamed name = do
  err <- makeGeneratedError (UnexpectedName name)
  throwParseError err


-- | === State Updates

-- | Changes the `ParserState` using the given function.
modifyParserState
  :: Parser e :> es
  => (ParserState -> ParserState)
  -> Eff es ()
modifyParserState f = do
  s <- getParseState
  putParseState (f s)


{- | Apply a function to the current state and returns the
result.
-}
gets
  :: Parser e :> es
  => (ParserState -> b)
  -> Eff es b
gets f =
  f <$> getParseState


-- | Updates the `Position` based on a character.
charUpdatePosition :: Position -> Char -> Position
charUpdatePosition s c =
  if c == '\n'
    then Position' {line = s.line + 1, column = 0, offset = s.offset + 1}
    else Position' {line = s.line, column = s.column + 1, offset = s.offset + 1}


{- | Updates the `ParserState`, it:
  - Updates the position based on the given Char
  - Sets the remain stream to the given stream
-}
charUpdateState :: Char -> Text -> ParserState -> ParserState
charUpdateState c newStream s =
  let newPos = charUpdatePosition s.position c
   in s {position = newPos, remainStream = newStream}


{- | Update the `ParserState` assuming it consumed the
given `Text` and sets the remain of the stream.
-}
textUpateState
  :: Text
  -- ^ Parsed stream
  -> Text
  -- ^ Remain stream
  -> ParserState
  -- ^ State to update
  -> ParserState
textUpateState parsed remain s =
  let newPosition = Text.foldl' charUpdatePosition s.position parsed
   in s {position = newPosition, remainStream = remain}


{- | Allow us to see the next character
and the remain text.
-}
lookupNextChar :: ParserState -> Maybe (Char, Text)
lookupNextChar s = Text.uncons s.remainStream


-- | == Basic combinators

{- | Gets the next char of the input, it throws a end of
input error if it doesn't exists.
-}
item
  :: Parser e :> es
  => Eff es Char
item = do
  s <- getParseState
  case Text.uncons s.remainStream of
    Just (current, remain) -> do
      modifyParserState $
        charUpdateState current remain
      pure current
    Nothing -> errorEof


{- | Consumes a element from the input and returns it if it
 match the given predicate or throws a unexpected error.
-}
satisfy
  :: Parser e
    :> es
  => Maybe String
  -- ^ A name for a character matched by the predicate.
  -> (Char -> Bool)
  -- \^ Predicate
  -> Eff es Char
satisfy maybeName predicate = do
  c <- item
  if predicate c
    then pure c
    else case maybeName of
      Just (x : y) ->
        errorNamed (x :| y)
      _ ->
        errorRaw (NonEmpty.singleton c)


{- | Allow us to check the next element on the stream without
consuming input or returns Nothing if we reached the eof.
This function doesn't throw.
-}
lookupNext
  :: Parser e :> es
  => Eff es (Maybe Char)
lookupNext = (fst <$>) <$> gets lookupNextChar

-- | Takes elements from the input stream as long as
-- it matches the predicate. It never fails even
-- when no input is matched.
takeWhileP
  :: Parser e :> es
  =>
  (Char -> Bool)
  -- \^ Predicate
  -> Eff es Text
takeWhileP predicate= do
  stream <- gets remainStream
  let match = Text.takeWhile predicate stream
  if Text.null match then
    pure match
  else
    let newStream = Text.drop (Text.length match) stream
     in do
      modifyParserState (textUpateState match newStream)
      pure match

-- | Takes elements from the input stream as long as
-- it matches the predicate. It parses at least one `Char`
-- otherwise it throws a error.
takeWhile1P
  :: Parser e :> es
  =>
  -- | A name for the `Char`s matched by the predicate.
  Maybe String
  ->
  (Char -> Bool)
  -- \^ Predicate
  -> Eff es Text
takeWhile1P maybeName predicate= do
  stream <- gets remainStream
  let match = Text.takeWhile predicate stream
  if Text.null match then
    case maybeName of
      Just (x:y) -> errorNamed (x:|y)
      _ ->
        case Text.uncons stream of
          Just (c,_) -> errorRaw (c:|[])
          Nothing -> errorEof
  else
    let newStream = Text.drop (Text.length match) stream
     in do
      modifyParserState (textUpateState match newStream)
      pure match

-- | Run a parser, and if it fails, restores the previous state.
try
  :: Parser e :> es
  => Eff es a
  -> Eff es a
try p = do
  state <- getParseState
  p `catchParseError` \e ->
    putParseState state >> throwParseError e

-- | Runs the first parser, if it fails without consuming input, runs the second parser.
-- If the first parser consumes input and fails, the whole alternative fails.
alternative
  :: Parser e :> es
  => Eff es a
  -> Eff es a
  -> Eff es a
alternative p1 p2 = do
  state <- getParseState
  p1 `catchParseError` \err1 -> do
    state' <- getParseState
    if position state' /= position state
      then throwParseError err1
      else p2

-- | Parses zero or one occurrence of p, returning Maybe.
optional
  :: Parser e :> es
  => Eff es a
  -> Eff es (Maybe a)
optional p = (Just <$> p) `alternative` pure Nothing

-- | Parses zero or more occurrences of p.
many
  :: Parser e :> es
  => Eff es a
  -> Eff es [a]
many p = try (some p) `alternative` pure []

-- | Parses one or more occurrences of p.
some
  :: Parser e :> es
  => Eff es a
  -> Eff es [a]
some p = do
  x <- p
  xs <- many p
  pure (x:xs)

-- | Parses zero or more occurrences of p separated by sep.
sepBy
  :: Parser e :> es
  => Eff es a
  -> Eff es sep
  -> Eff es [a]
sepBy p sep = sepBy1 p sep `alternative` pure []

-- | Parses one or more occurrences of p separated by sep.
sepBy1
  :: Parser e :> es
  => Eff es a
  -> Eff es sep
  -> Eff es [a]
sepBy1 p sep = do
  x <- p
  xs <- many (sep *> p)
  pure (x:xs)
